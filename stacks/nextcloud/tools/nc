#!/usr/bin/env bash
# SPDX-License-Identifier: Apache-2.0
# Nextcloud stack helper
# - Consistent docker compose entrypoints for base + runtime override
# - Optional profiles (e.g. "monitoring") for exporters or extra services
# - Defensive down: includes monitoring profile if exporters are present
set -euo pipefail

# ---------- Defaults (export to override) ----------
WORKSPACE=${WORKSPACE:-$HOME/Proyectos/Curro}
STACKS_REPO=${STACKS_REPO:-"$WORKSPACE/homelab-stacks"}
RUNTIME_DIR=${RUNTIME_DIR:-"$WORKSPACE/homelab-runtime/stacks/nextcloud"}
ENV_FILES=${ENV_FILES:-"$RUNTIME_DIR/.env"}
QUIET=${QUIET:-0}                 # 1 = reduced output

# Optional, space-separated: e.g. PROFILES="monitoring debug"
PROFILES=${PROFILES:-}

# Curl image for lightweight HTTP checks
CURL_IMG=${CURL_IMG:-curlimages/curl:8.10.1}
NC_OCC_TIMEOUT=${NC_OCC_TIMEOUT:-15s}

PROJECT_DIR="$STACKS_REPO/stacks/nextcloud"
BASE_FILE="$PROJECT_DIR/compose.yaml"
OVRD_FILE=""
if [[ -f "$RUNTIME_DIR/compose.override.yaml" ]]; then
  OVRD_FILE="$RUNTIME_DIR/compose.override.yaml"
elif [[ -f "$RUNTIME_DIR/compose.override.yaml" ]]; then
  OVRD_FILE="$RUNTIME_DIR/compose.override.yaml"
fi

# ---------- Compose command builders ----------
# Build "--profile ..." flags for the current PROFILES set
build_profile_flags() {
  local flags=""
  if [[ -n "${PROFILES}" ]]; then
    for p in ${PROFILES}; do
      [[ -n "$p" ]] && flags+=" --profile $p"
    done
  fi
  printf '%s' "$flags"
}

build_env_flags() {
  local flags=""
  local f
  for f in ${ENV_FILES}; do
    [[ -n "$f" ]] && flags+=" --env-file \"$f\""
  done
  printf '%s' "$flags"
}

# Build compose args without eval (safe for status/down/reset-db)
# For 'down': include current profiles and, if exporters are detected,
# ensure "--profile monitoring" is present even if not specified.
build_profile_flags_for_down() {
  local flags
  flags="$(build_profile_flags)"
  if exporters_present && ! has_profile "monitoring"; then
    flags+=" --profile monitoring"
  fi
  printf '%s' "$flags"
}

PROF_STR="$(build_profile_flags)"
ENV_STR="$(build_env_flags)"

BASE="docker compose$ENV_STR$PROF_STR --project-directory \"$PROJECT_DIR\" -f \"$BASE_FILE\""
if [[ -n "$OVRD_FILE" ]]; then
  OVRD="docker compose$ENV_STR$PROF_STR --project-directory \"$PROJECT_DIR\" -f \"$BASE_FILE\" -f \"$OVRD_FILE\""
  OVRD_MON="docker compose$ENV_STR --profile monitoring --project-directory \"$PROJECT_DIR\" -f \"$BASE_FILE\" -f \"$OVRD_FILE\""
else
  OVRD="$BASE"
  OVRD_MON="docker compose$ENV_STR --profile monitoring --project-directory \"$PROJECT_DIR\" -f \"$BASE_FILE\""
fi

# ---------- Helpers ----------
log()  { echo "▶ $*"; }
run()  { if [ "$QUIET" = "1" ]; then eval "$*" >/dev/null 2>&1; else eval "$*"; fi; }
dc_exec() { eval "$OVRD exec -T $*"; }
occ()  { dc_exec -w /var/www/html -u www-data app php occ "$@"; }

dc_base() {
  local -a args=(docker compose --project-directory "$PROJECT_DIR")
  local f p
  for f in ${ENV_FILES}; do
    [[ -n "$f" ]] && args+=(--env-file "$f")
  done
  if [[ -n "${PROFILES}" ]]; then
    for p in ${PROFILES}; do
      [[ -n "$p" ]] && args+=(--profile "$p")
    done
  fi
  args+=(-f "$BASE_FILE")
  "${args[@]}" "$@"
}

dc_ovrd() {
  local -a args=(docker compose --project-directory "$PROJECT_DIR")
  local f p
  for f in ${ENV_FILES}; do
    [[ -n "$f" ]] && args+=(--env-file "$f")
  done
  if [[ -n "${PROFILES}" ]]; then
    for p in ${PROFILES}; do
      [[ -n "$p" ]] && args+=(--profile "$p")
    done
  fi
  args+=(-f "$BASE_FILE")
  [[ -n "$OVRD_FILE" ]] && args+=(-f "$OVRD_FILE")
  "${args[@]}" "$@"
}

dc_mon() {
  local -a args=(docker compose --project-directory "$PROJECT_DIR")
  local f
  for f in ${ENV_FILES}; do
    [[ -n "$f" ]] && args+=(--env-file "$f")
  done
  args+=(--profile monitoring)
  args+=(-f "$BASE_FILE")
  [[ -n "$OVRD_FILE" ]] && args+=(-f "$OVRD_FILE")
  "${args[@]}" "$@"
}

dc_base_timeout() {
  local duration="$1"
  shift
  local -a args=(docker compose --project-directory "$PROJECT_DIR")
  local f p
  for f in ${ENV_FILES}; do
    [[ -n "$f" ]] && args+=(--env-file "$f")
  done
  if [[ -n "${PROFILES}" ]]; then
    for p in ${PROFILES}; do
      [[ -n "$p" ]] && args+=(--profile "$p")
    done
  fi
  args+=(-f "$BASE_FILE")
  timeout "$duration" "${args[@]}" "$@"
}

dc_ovrd_timeout() {
  local duration="$1"
  shift
  local -a args=(docker compose --project-directory "$PROJECT_DIR")
  local f p
  for f in ${ENV_FILES}; do
    [[ -n "$f" ]] && args+=(--env-file "$f")
  done
  if [[ -n "${PROFILES}" ]]; then
    for p in ${PROFILES}; do
      [[ -n "$p" ]] && args+=(--profile "$p")
    done
  fi
  args+=(-f "$BASE_FILE")
  [[ -n "$OVRD_FILE" ]] && args+=(-f "$OVRD_FILE")
  timeout "$duration" "${args[@]}" "$@"
}

has_profile() {
  # usage: has_profile <name>
  [[ " ${PROFILES:-} " =~ [[:space:]]$1[[:space:]] ]]
}

exporters_present() {
  eval "$OVRD_MON ps -q mysqld-exporter redis-exporter" | grep -q .
}

wait_for_code() {
  log "Waiting for Nextcloud application code to be available..."
  until dc_exec app test -f /var/www/html/occ; do sleep 1; done
  until dc_exec app test -f /var/www/html/lib/versioncheck.php; do sleep 1; done
}

ensure_config_dir() {
  dc_exec -u root app sh -lc 'install -d -o 33 -g 33 -m 0750 /var/www/html/config'
}

seed_snippets() {
  ensure_config_dir
  for f in 10-redis.config.php 20-proxy.config.php; do
    if ! dc_exec -u root app test -f "/var/www/html/config/$f"; then
      run "$OVRD cp \"$STACKS_REPO/stacks/nextcloud/config/$f.example\" app:/var/www/html/config/$f"
      dc_exec -u root app chown 33:33 "/var/www/html/config/$f" || true
    fi
  done
}

is_installed() {
  dc_exec -w /var/www/html -u www-data app sh -lc \
    'php occ status 2>/dev/null | grep -q "installed: true"' >/dev/null 2>&1
}

wait_until_installed() {
  for _ in $(seq 1 120); do
    if is_installed; then return 0; fi
    sleep 1
  done
  return 1
}

usage() {
  cat >&2 <<'USAGE'
Usage: nc {up|install|post|status|logs|reset-db|down}

Environment:
  PROFILES="monitoring"   Enable profiled services (e.g., exporters)
  QUIET=1                 Reduce output noise
  CURL_IMG=...            Container image for HTTP checks (default: curlimages/curl:8.10.1)
  NC_OCC_TIMEOUT=15s      Timeout for occ fallback in status (default: 15s)
USAGE
}

# ---------- Commands ----------
case "${1:-}" in
  up)
    mkdir -p "$RUNTIME_DIR"
    log "Starting database and Redis"
    run "$BASE up -d db redis"

    log "Starting application, web, and cron"
    run "$OVRD up -d app web cron"

    if has_profile monitoring; then
      log "Starting monitoring exporters"
      run "$OVRD up -d mysqld-exporter redis-exporter"
    fi
    ;;

  install)
    wait_for_code
    ensure_config_dir
    if is_installed; then
      log "[install] Already installed — skipping"
    else
      log "[install] Waiting for application to complete self-installation..."
      if ! wait_until_installed; then
        echo "ERROR: Nextcloud not installed within the expected time. Check 'tools/nc logs'." >&2
        exit 1
      fi
    fi
    seed_snippets
    ;;

  post)
    wait_for_code
    if ! is_installed; then
      log "[post] Skipping — application not installed yet"
      exit 0
    fi
    seed_snippets
    occ background:cron || true
    dc_exec -w /var/www/html -u www-data app sh -lc '
      if [ -n "${NEXTCLOUD_TRUSTED_DOMAINS:-${NC_DOMAIN:-}}" ]; then
        php occ config:system:set trusted_domains 1 --value "${NEXTCLOUD_TRUSTED_DOMAINS:-${NC_DOMAIN:-}}"
      fi
      php occ config:system:set trusted_domains 2 --value "web"
      php occ config:system:set trusted_domains 3 --value "localhost"
    ' || true
    if [ -n "${NC_DOMAIN:-}" ]; then
      occ config:system:set overwrite.cli.url --value="https://${NC_DOMAIN}" || true
    fi
    occ db:add-missing-indices || true
    occ maintenance:repair || true
    occ status || true
    ;;

  status)
    web_id="$(dc_ovrd ps -q web 2>/dev/null || true)"
    app_id="$(dc_ovrd ps -q app 2>/dev/null || true)"
    if [[ -z "$web_id" || -z "$app_id" ]]; then
      echo "stack: down (web/app containers not found)"
      exit 0
    fi

    echo "stack: up"

    installed="unknown"
    reason=""
    http_out=""
    http_host_out=""

    set +e
    http_line="$(timeout 6s docker run --rm --network "container:${web_id}" "$CURL_IMG" -sSI --connect-timeout 2 --max-time 5 http://127.0.0.1:8080/status.php 2>/dev/null | head -n1)"
    http_rc=$?
    set -e
    if [[ "$http_rc" -eq 0 && -n "$http_line" ]]; then
      http_out="http: ${http_line}"
    else
      http_reason="failed"
      [[ "$http_rc" -eq 124 ]] && http_reason="timeout"
      http_out="http: fail (${http_reason})"
    fi

    http_code=""
    if [[ "$http_rc" -eq 0 && -n "${http_line:-}" ]]; then
      http_code="$(awk 'NR==1{print $2}' <<<"$http_line")"
    fi
    skip_occ=0
    if [[ -n "$http_code" && "$http_code" =~ ^[0-9]{3}$ ]]; then
      if (( http_code >= 400 )); then
        skip_occ=1
        reason="http-${http_code}"
      fi
    fi

    set +e
    http_body="$(timeout 6s docker run --rm --network "container:${web_id}" "$CURL_IMG" -fsS --connect-timeout 2 --max-time 5 http://127.0.0.1:8080/status.php 2>/dev/null)"
    http_body_rc=$?
    set -e
    if [[ "$http_body_rc" -eq 0 && -n "$http_body" ]]; then
      installed_val="$(printf '%s' "$http_body" | tr -d ' \n\r\t' | grep -oE '\"installed\":(true|false)' | head -n1 | cut -d: -f2)"
      if [[ -n "$installed_val" ]]; then
        installed="$installed_val"
      else
        reason="http-parse-failed"
      fi
    else
      reason="http-failed"
    fi

    if [[ -n "${NC_DOMAIN:-}" ]]; then
      set +e
      http_host_line="$(timeout 6s docker run --rm --network "container:${web_id}" "$CURL_IMG" -sSI --connect-timeout 2 --max-time 5 -H "Host: ${NC_DOMAIN}" http://127.0.0.1:8080/status.php 2>/dev/null | head -n1)"
      http_host_rc=$?
      set -e
      if [[ "$http_host_rc" -eq 0 && -n "$http_host_line" ]]; then
        http_host_out="http(host): ${http_host_line}"
      else
        http_host_reason="failed"
        [[ "$http_host_rc" -eq 124 ]] && http_host_reason="timeout"
        http_host_out="http(host): fail (${http_host_reason})"
      fi

      if [[ "$installed" = "unknown" ]]; then
        set +e
        http_host_body="$(timeout 6s docker run --rm --network "container:${web_id}" "$CURL_IMG" -fsS --connect-timeout 2 --max-time 5 -H "Host: ${NC_DOMAIN}" http://127.0.0.1:8080/status.php 2>/dev/null)"
        http_host_body_rc=$?
        set -e
        if [[ "$http_host_body_rc" -eq 0 && -n "$http_host_body" ]]; then
          installed_val="$(printf '%s' "$http_host_body" | tr -d ' \n\r\t' | grep -oE '\"installed\":(true|false)' | head -n1 | cut -d: -f2)"
          if [[ -n "$installed_val" ]]; then
            installed="$installed_val"
            reason=""
          else
            reason="http-host-parse-failed"
          fi
        else
          reason="http-host-failed"
        fi
      fi
    fi

    if [[ "$installed" = "unknown" && "${skip_occ}" -eq 0 ]]; then
      set +e
      occ_out="$(dc_ovrd_timeout "$NC_OCC_TIMEOUT" exec -T -w /var/www/html -u www-data app php occ status 2>/dev/null)"
      occ_rc=$?
      set -e
      if [[ "$occ_rc" -eq 0 ]]; then
        if echo "$occ_out" | grep -q "installed: true"; then
          installed="true"
          reason=""
        elif echo "$occ_out" | grep -q "installed: false"; then
          installed="false"
          reason=""
        else
          reason="occ-parse-failed"
        fi
      elif [[ "$occ_rc" -eq 124 ]]; then
        reason="occ-timeout"
      else
        reason="occ-exec-failed"
      fi
    fi

    if [[ "$installed" = "unknown" ]]; then
      echo "installed: unknown (${reason})"
    else
      echo "installed: ${installed}"
    fi
    echo "${http_out:-http: fail (unknown)}"
    if [[ -n "${http_host_out:-}" ]]; then
      echo "${http_host_out}"
    fi
    ;;

  logs)
    run "$OVRD logs -f app"
    ;;

  reset-db)
    log "Resetting ONLY the database volume (application data remains)"
    db_id="$(dc_ovrd ps -q db 2>/dev/null || true)"
    if [[ -z "$db_id" ]]; then
      log "DB container not found; starting db service to detect volume"
      set +e
      dc_ovrd_timeout 20s up -d db >/dev/null 2>&1
      start_rc=$?
      set -e
      if [[ "$start_rc" -ne 0 ]]; then
        echo "error: failed to start db service for volume detection" >&2
        exit 1
      fi
      db_id="$(dc_ovrd ps -q db 2>/dev/null || true)"
    fi

    if [[ -z "$db_id" ]]; then
      echo "error: db container not found; cannot determine volume safely" >&2
      exit 1
    fi

    set +e
    db_mounts="$(timeout 5s docker inspect --format '{{range .Mounts}}{{if eq .Destination "/var/lib/mysql"}}{{.Type}}:{{.Name}}{{"\n"}}{{end}}{{end}}' "$db_id" 2>/dev/null)"
    inspect_rc=$?
    set -e
    if [[ "$inspect_rc" -eq 124 ]]; then
      echo "error: timeout while inspecting db container mounts" >&2
      exit 1
    elif [[ "$inspect_rc" -ne 0 ]]; then
      echo "error: failed to inspect db container mounts" >&2
      exit 1
    fi

    db_vol_count="$(printf '%s' "$db_mounts" | grep -c '^volume:' || true)"
    if [[ "$db_vol_count" -ne 1 ]]; then
      echo "error: ambiguous db volume; expected 1 volume at /var/lib/mysql, got ${db_vol_count}" >&2
      exit 1
    fi

    db_vol_name="$(printf '%s' "$db_mounts" | awk -F: '$1=="volume"{print $2}' | head -n1)"
    if [[ -z "$db_vol_name" ]]; then
      echo "error: db volume name not found; aborting for safety" >&2
      exit 1
    fi

    echo "INFO: removing db volume: ${db_vol_name}"
    set +e
    dc_ovrd_timeout 10s stop db >/dev/null 2>&1
    dc_ovrd_timeout 10s rm -f db >/dev/null 2>&1
    timeout 10s docker volume rm "${db_vol_name}" >/dev/null 2>&1
    rm_rc=$?
    set -e
    if [[ "$rm_rc" -ne 0 ]]; then
      echo "error: failed to remove db volume ${db_vol_name}" >&2
      exit 1
    fi

    dc_ovrd_timeout 20s up -d db redis
    ;;

  down)
    down_profiles="${PROFILES:-}"
    if exporters_present && ! has_profile "monitoring"; then
      down_profiles="${down_profiles} monitoring"
    fi

    if [[ " ${down_profiles} " =~ [[:space:]]monitoring[[:space:]] ]]; then
      log "Stopping stack (including monitoring profile)"
    else
      log "Stopping stack"
    fi

    down_args=(docker compose --project-directory "$PROJECT_DIR")
    for f in ${ENV_FILES}; do
      [[ -n "$f" ]] && down_args+=(--env-file "$f")
    done
    for p in ${down_profiles}; do
      [[ -n "$p" ]] && down_args+=(--profile "$p")
    done
    down_args+=(-f "$BASE_FILE")
    [[ -n "$OVRD_FILE" ]] && down_args+=(-f "$OVRD_FILE")

    "${down_args[@]}" down --remove-orphans

    # Safety net: ensure exporters are fully removed.
    dc_mon rm -f mysqld-exporter redis-exporter >/dev/null 2>&1 || true
    ;;

  *)
    usage; exit 1 ;;
esac
